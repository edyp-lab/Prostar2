#     hr(),
#     uiOutput("helpTextMV"),
#     uiOutput("Warning_VizualizeFilteredData"),
#     DT::dataTableOutput("VizualizeFilteredData")
#   )
# })
#
# output$legendForExprsData2 <- renderUI({
#   req(input$ChooseTabAfterFiltering)
#
#   if (input$ChooseTabAfterFiltering != "quantiData"){return(NULL)}
#   moduleLegendColoredExprsUI("FilterColorLegend_DS", rv$colorsTypeMV)
# })
#
#
# output$helpTextMV <- renderUI({
#   helpText("After checking the data, validate the filters.")
# })
#
#
# output$Warning_VizualizeFilteredData <- renderUI({
#   if (length(GetDataFor_VizualizeFilteredData())==0){return(NULL)}
#   if (nrow(GetDataFor_VizualizeFilteredData())>153)
#     p(MSG_WARNING_SIZE_DT)
#
# })
#
#
# output$Warning_VizualizeFilteredData <- renderUI({
#   if (length(GetDataFor_VizualizeFilteredData())==0){return(NULL)}
#   if (nrow(GetDataFor_VizualizeFilteredData())>153)
#     p(MSG_WARNING_SIZE_DT)
#
# })
#
#
#
# ###################################################
# ## Screen 5 ##
# ###################################################
# output$screenFiltering5 <- renderUI({
#
#   tagList(
#     actionButton("ValidateFilters","Save filtered dataset",class = actionBtnClass)
#   )
# })
###################################################
## Input effects ##
###################################################
# Screen 1
observeEvent(input$ChooseFilters,ignoreInit=TRUE,{
rv$widgets$filtering$ChooseFilters <- input$ChooseFilters
})
observeEvent(input$perform.filtering.MV,ignoreInit=TRUE,{
rv$widgets$filtering$ChooseFilters
input$seuilNA
if (rv$widgets$filtering$ChooseFilters == gFilterNone){
#rv$current.obj <- rv$dataset[[input$datasets]]
} else {
keepThat <- mvFilterGetIndices(rv$current.obj,
rv$widgets$filtering$ChooseFilters,
as.integer(input$seuilNA))
if (!is.null(keepThat))
{
rv$deleted.mvLines <- rv$current.obj[-keepThat]
rv$current.obj <- mvFilterFromIndices(rv$current.obj,
keepThat,
GetFilterText(rv$widgets$filtering$ChooseFilters, as.integer(input$seuilNA)))
rvModProcess$moduleFilteringDone[1] <- TRUE
}
}
})
# # Screen 2
# observeEvent(input$actionButtonFilter,{
#   req(input$symFilter_cname)
#   temp <- rv$current.obj
#
#   if (input$symFilter_cname=="None"){return()}
#   cname <- input$symFilter_cname
#   tagName <- input$symFilter_tagName
#   res <- StringBasedFiltering2(temp,cname, input$symFilter_tagName)
#   nbDeleted <- 0
#
#   if (!is.null(res[["deleted"]])){
#     rv$deleted.stringBased <- rbindMSnset(rv$deleted.stringBased, res[["deleted"]])
#     nbDeleted <-  nrow(res[["deleted"]])
#   } else {
#     nbDeleted <-  0
#   }
#   rv$current.obj <- res[["obj"]]
#   rvModProcess$moduleFilteringDone[2] <- TRUE
#
#   df <- data.frame(Filter=cname, Prefix=tagName, nbDeleted=nbDeleted, Total=nrow(rv$current.obj))
#   rv$widgets$filtering$DT_filterSummary <- rbind(rv$widgets$filtering$DT_filterSummary , df)
# })
#
#
#
# observeEvent(input$actionButtonFilter,{
#   req(input$symFilter_cname)
#   temp <- rv$current.obj
#
#   if (input$symFilter_cname=="None"){return()}
#   cname <- input$symFilter_cname
#   tagName <- input$symFilter_tagName
#   res <- StringBasedFiltering2(temp,cname, input$symFilter_tagName)
#   nbDeleted <- 0
#
#   if (!is.null(res[["deleted"]])){
#     rv$deleted.stringBased <- rbindMSnset(rv$deleted.stringBased, res[["deleted"]])
#     nbDeleted <-  nrow(res[["deleted"]])
#   } else {
#     nbDeleted <-  0
#   }
#   rv$current.obj <- res[["obj"]]
#   rvModProcess$moduleFilteringDone[2] <- TRUE
#
#   df <- data.frame(Filter=cname, Prefix=tagName, nbDeleted=nbDeleted, Total=nrow(rv$current.obj))
#   rv$widgets$filtering$DT_filterSummary <- rbind(rv$widgets$filtering$DT_filterSummary , df)
# })
#
#
#
# observeEvent(input$actionButtonFilter,{
#   req(input$symFilter_cname)
#   temp <- rv$current.obj
#
#   if (input$symFilter_cname=="None"){return()}
#   cname <- input$symFilter_cname
#   tagName <- input$symFilter_tagName
#   res <- StringBasedFiltering2(temp,cname, input$symFilter_tagName)
#   nbDeleted <- 0
#
#   if (!is.null(res[["deleted"]])){
#     rv$deleted.stringBased <- rbindMSnset(rv$deleted.stringBased, res[["deleted"]])
#     nbDeleted <-  nrow(res[["deleted"]])
#   } else {
#     nbDeleted <-  0
#   }
#   rv$current.obj <- res[["obj"]]
#   rvModProcess$moduleFilteringDone[2] <- TRUE
#
#   df <- data.frame(Filter=cname, Prefix=tagName, nbDeleted=nbDeleted, Total=nrow(rv$current.obj))
#   rv$widgets$filtering$DT_filterSummary <- rbind(rv$widgets$filtering$DT_filterSummary , df)
# })
#
#
#
#
# # Screen 3
# observeEvent(input$btn_numFilter,ignoreInit=TRUE,{
#   temp <- rv$current.obj
#
#   if (input$numericFilter_cname=="None"){return()}
#   cname <- input$numericFilter_cname
#   tagValue <- input$numericFilter_value
#
#   print(input$numericFilter_value)
#   print(input$numericFilter_operator)
#   res <- NumericalFiltering(temp,cname, input$numericFilter_value,input$numericFilter_operator)
#   nbDeleted <- 0
#
#
#   if (!is.null(res[["deleted"]])){
#     rv$deleted.numeric <- rbindMSnset(rv$deleted.numeric, res[["deleted"]])
#     nbDeleted <-  nrow(res[["deleted"]])
#   } else {
#     nbDeleted <-  0
#   }
#   rv$current.obj <- res[["obj"]]
#   rvModProcess$moduleFilteringDone[3] <- TRUE
#
#   df <- data.frame(Filter=cname,
#                    Condition=paste0(input$numericFilter_operator,' ',tagValue),
#                    nbDeleted=nbDeleted,
#                    Total=nrow(rv$current.obj))
#   rv$widgets$filtering$DT_numfilterSummary <- rbind(rv$widgets$filtering$DT_numfilterSummary, df)
# })
#
#
# # Screen 4
# output$legendForExprsData2 <- renderUI({
#   req(input$ChooseTabAfterFiltering)
#
#   if (input$ChooseTabAfterFiltering != "quantiData"){return(NULL)}
#   moduleLegendColoredExprsUI("FilterColorLegend_DS", rv$colorsTypeMV)
#
# })
#
#
# GetDataFor_VizualizeFilteredData <- reactive({
#   req(rv$settings_nDigits)
#   rv$deleted.mvLines
#   req(input$ChooseViewAfterFiltering)
#   req(input$ChooseTabAfterFiltering)
#   rv$deleted.stringBased
#   rv$deleted.numeric
#   #print("DANS REACTIVE : GetDataFor_VizualizeFilteredData")
#
#   data <- NULL
#   if ((input$ChooseViewAfterFiltering == "MissingValues") && !is.null(rv$deleted.mvLines))
#   {
#     #print("DANS REACTIVE : If 1")
#     #print(dim(getDataForMVFiltered()))
#     switch(input$ChooseTabAfterFiltering,
#            quantiData =  data <- getDataForMVFiltered(),
#            metaData = data <- cbind(ID = rownames(Biobase::fData(rv$deleted.mvLines)), Biobase::fData(rv$deleted.mvLines))
#     )
#   }
#
#   else if ((input$ChooseViewAfterFiltering == "StringBased") && !is.null(rv$deleted.stringBased)) {
#
#     #print("DANS REACTIVE : If 2")
#     switch(input$ChooseTabAfterFiltering,
#            quantiData =  data <- getDataForMVStringFiltered(),
#            metaData = data <- Biobase::fData(rv$deleted.stringBased)
#     )
#   }  else if ((input$ChooseViewAfterFiltering == "Numerical") && !is.null(rv$deleted.numeric)) {
#     #print("DANS REACTIVE : If 3")
#     switch(input$ChooseTabAfterFiltering,
#            quantiData =  data <- getDataForNumericalFiltered(),
#            metaData = data <- Biobase::fData(rv$deleted.numeric)
#     )
#   }
#
#   # print("END OF REACTIVE")
#   #print(data)
#   data
# })
#
#
# output$VizualizeFilteredData <- DT::renderDataTable(server=TRUE,{
#   input$ChooseTabAfterFiltering
#   req(GetDataFor_VizualizeFilteredData())
#   dt <- NULL
#   data <- GetDataFor_VizualizeFilteredData()
#
#   if(input$ChooseTabAfterFiltering =="quantiData"){
#     dt <- DT::datatable( data,
#                          extensions = c('Scroller', 'Buttons'),
#                          options = list(
#                            buttons = list('copy',
#                                           list(
#                                             extend = 'csv',
#                                             filename = 'Prostar_export'),
#                                           'print'),
#                            dom='Brtip',
#                            initComplete = initComplete(),
#                            displayLength = 20,
#                            deferRender = TRUE,
#                            bLengthChange = FALSE,
#                            scrollX = 200,
#                            scrollY = 600,
#                            scroller = TRUE,
#                            ordering=FALSE,
#                            columnDefs = list(list(targets = c(((ncol(data)/2)+1):ncol(data)), visible = FALSE),
#                                              list(width='150px',targets= "_all"))
#                          )
#     ) %>%
#       formatStyle(
#         colnames(data)[1:(ncol(data)/2)],
#         colnames(data)[((ncol(data)/2)+1):ncol(data)],
#         backgroundColor = styleEqual(c("POV", "MEC"), c(rv$colorsTypeMV$POV, rv$colorsTypeMV$MEC))
#       )
#   } else {
#     dt <- DT::datatable( data,
#                          extensions = 'Scroller',
#                          options = list(initComplete = initComplete(),
#                                         displayLength = 20,
#                                         deferRender = TRUE,
#                                         bLengthChange = FALSE,
#                                         scrollX = 200,
#                                         scrollY = 600,
#                                         scroller = TRUE,
#                                         ordering=FALSE))
#   }
#   # }
#   dt
#
# })
#
#
#
#
# # Screen 5
# observeEvent(input$ValidateFilters,ignoreInit = TRUE,{
#
#   isolate({
#     if((rv$widgets$filtering$ChooseFilters != gFilterNone)
#        || (nrow(rv$widgets$filtering$DT_filterSummary )>1)
#        || (nrow(rv$widgets$filtering$DT_numfilterSummary )>1)){
#       l.params <- build_ParamsList_Filtering()
#
#       rv$typeOfDataset <- rv$current.obj@experimentData@other$typeOfData
#       name <- paste0("Filtered", ".", rv$typeOfDataset)
#       rv$current.obj <- saveParameters(rv$current.obj,name,"Filtering",l.params)
#       dataOut<- rv$current.obj
#       rvModProcess$moduleFilteringDone[5] <- TRUE
#
#       if (rv$typeOfDataset == "peptide"  && !is.null(rv$proteinId)){
#         ComputeAdjacencyMatrices()
#         ComputeConnexComposants()
#       }
#       UpdateDatasetWidget(rv$current.obj, name)
#     }
#     rvModProcess$moduleFilteringDone[5] <- TRUE
#   })
#
# })
}
## To be copied in the UI
# mod_filtering_protein_ui("filtering_protein_ui_1")
## To be copied in the server
# callModule(mod_filtering_protein_server, "filtering_protein_ui_1")
runApp('dev/test_dev/test-mod_filtering_protein.R')
source(file.path('~/Github/2.0/Prostar2/R', 'mod_filtering_protein.R'), local=TRUE)$value
ui <- fluidPage(
mod_filtering_protein_ui('filtering_protein')
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
library(DAPARdata)
data("Exp1_R25_prot")
# obj est un msnset de type protein
callModule(mod_filtering_protein_server,'filtering_protein', obj = reactive({Exp1_R25_prot}))
}
shinyApp(ui, server)
ui
server
ui <- fluidPage(
mod_filtering_protein_ui('filtering_protein')
)
getwd()
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
library(shiny); runApp('dev/test_dev/test-mod_infos_dataset.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source(file.path('~/Github/2.0/Prostar2/R', 'mod_filtering_protein.R'), local=TRUE)$value
ui <- fluidPage(
mod_filtering_protein_ui('filtering_protein')
)
ui <- fluidPage(
mod_filtering_protein_ui('filtering_protein')
)
mod_filtering_protein_ui <- fluidPage(
tagList(
br(),br(),
mod_navigation_ui('nav')
)
)
#' @param input internal
#' @param output internal
#' @param session internal
#' @param obj xxxx
#'
#' @rdname mod_infos_dataset
#'
#' @keywords internal
#' @export
#' @importFrom shiny NS tagList
mod_infos_dataset_ui <- function(id){
ns <- NS(id)
tagList(
fluidRow(
column(width=6,
h4("MAE summary"),
mod_format_DT_ui(ns('dt'))
),
column(width=6,
selectInput(ns("selectInputMsnset"),
"Select a dataset for further information",
choices = c("None",names(dat@ExperimentList@listData))),
uiOutput(ns('selectMsnset'))
)
)
)
}
mod_filtering_protein_ui <- fluidPage(
ns <- NS(id)
tagList(
br(),br(),
mod_navigation_ui(ns('nav'))
)
)
mod_filtering_protein_ui <- fluidPage(
ns <- NS(id)
tagList(
br(),br(),
mod_navigation_ui(ns('nav'))
)
)
mod_filtering_protein_ui <- function(id){
ns <- NS(id)
fluidPage(
tagList(
br(),br(),
mod_navigation_ui(ns('nav'))
)
)
}
ui <- fluidPage(
mod_filtering_protein_ui('filtering_protein')
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
library(DAPARdata)
data("Exp1_R25_prot")
# obj est un msnset de type protein
callModule(mod_filtering_protein_server,'filtering_protein', obj = reactive({Exp1_R25_prot}))
}
shinyApp(ui=ui, server=server)
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
library(shiny); runApp('dev/test_dev/test-mod_filtering_protein.R')
source(file.path('~/Github/2.0/DAPAR/R', 'missingValuesFilter.R'), local=TRUE)$value
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
library(shiny); runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
getwd()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# Document and reload your package
golem::document_and_reload()
source(file.path('~/Github/2.0/Prostar2/R', 'mod_filtering_protein.R'), local=TRUE)$value
source(file.path('~/Github/2.0/DAPAR/R', 'missingValuesFilter.R'), local=TRUE)$value
ui <- fluidPage(
mod_filtering_protein_ui('filtering_protein')
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
library(DAPARdata)
data("Exp1_R25_prot")
# obj est un msnset de type protein
callModule(mod_filtering_protein_server,'filtering_protein', obj = reactive({Exp1_R25_prot}))
}
shinyApp(ui=ui, server=server)
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_navigation.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
#default values for the widgets
r.widgets <- reactiveValues(
ChooseFilters <- "None"#,
#   seuilNA <- input$seuilNA
)
runApp('dev/test_dev/test-mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
source('~/Github/2.0/Prostar2/R/mod_filtering_protein.R')
runApp('dev/test_dev/test-mod_filtering_protein.R')
