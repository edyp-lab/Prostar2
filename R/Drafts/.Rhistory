#' @title Get the analysis slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @return The value of the slot called analysis
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("analysis", "PipelineTemplate", function(obj) {
out <- obj@analysis
out
})
#' @title Get the pipelineType slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @return The value of the slot called pipelineType
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("pipelineType", "PipelineTemplate", function(obj) {
out <- obj@pipelineType
out
})
#' @title Get the processes slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @return The value of the slot called processes
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("processes", "PipelineTemplate", function(obj) {
out <- obj@processes
out
})
#' @export
setGeneric("PairwiseComps", function(obj) standardGeneric("PairwiseComps"))
##
## Create getter methods for 2D data structures
##
#' @title Get the PairwiseComps slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @return The value of the slot called PairwiseComps
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("PairwiseComps", "PipelineTemplate", function(obj) {
out <- obj@PairwiseComparisons
out
})
#' @export
setGeneric("designMap", function(obj) standardGeneric("designMap"))
##
## Create getter methods for 2D data structures
##
#' @title Get the designMap slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @return The value of the slot called designMap
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("designMap", "PipelineTemplate", function(obj) {
out <- Biobase::pData(MultiAssayExperiment::experiments(obj)[['original']])
out
})
# For MultiAssayExperiment slots
# The getter methods defined in MultiAssayExperiment can be directly used to retrieve
# data from slots in the base class. These should generally not require any re-defining
# for a derived class. However, if it is necessary, the methods should use callNextMethod
# internally. This will call the method for the base MultiAssayExperiment class, the output
# of which can be modified as required.
# We use setValidity2 to define a validity function for PipelineTemplate. We use the previously
# defined getter functions to retrieve the slot values rather than using @. This is generally
# a good idea to keep the interface separate from the implementation
# (This protects against changes to the slot names, and simplifies development when the
#   storage mode differs from the conceptual meaning of the data, e.g., for efficiency
#   purposes.)
# We also set withDimnames=FALSE in our getter calls, as consistent naming is not necessary
# for internal functions.
# Creating a show method
# The default show method will only display information about the MultiAssayExperiment slots.
# We can augment it to display some relevant aspects of the custom slots. This is done by
# calling the base show method before printing additional fields as necessary.
#' @title show function override
#' @description sfklsjhf qsjdhsqd.
#' @param object xxxx
#' @return The value of the slot called designMap
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("show", "PipelineTemplate", function(object) {
cat(
"The name of the pipeline is ", pipelineType(object), " \n",
"The pipeline is composed of the following processes: ", processes(object), " \n",
"The name of the analysis is ", analysis(object), " \n",
"Built under Prostar version ", version(object), " \n",
sep=""
)
cat('-----------------------------------------\n')
callNextMethod()
})
# Creating setter methods
# 3.6.1 For 1D data structures
# We define some setter methods for the custom slots containing the 1D structures.
# Again, this usually requires the creation of new generics.
#' @export
setGeneric("pipelineType<-", function(obj, value) standardGeneric("pipelineType<-"))
#' @export
setGeneric("analysis<-", function(obj, value) standardGeneric("analysis<-"))
#' @export
setGeneric("processes<-", function(obj, value) standardGeneric("processes<-"))
# We define the class-specific methods for these generics. Note that use of validObject
# to ensure that the assigned input is still valid.
#' @title Set the pipelineType slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param value xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setReplaceMethod("pipelineType", "PipelineTemplate", function(obj, value) {
x@pipelineType <- value
validObject(x)
x
})
#' @title Set the processes slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param value xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setReplaceMethod("processes", "PipelineTemplate", function(obj, value) {
obj@processes <- value
validObject(obj)
obj
})
#' @title Set the analysis slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param value xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setReplaceMethod("analysis", "PipelineTemplate", function(obj, value) {
obj@analysis <- value
validObject(obj)
obj
})
# For 2D data structures
# We repeat this process for the 2D structures.
#' @export
setGeneric("PairwiseComps<-", function(obj, ..., value) standardGeneric("PairwiseComps<-"))
#' @title Set the PairwiseComps slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param value xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setReplaceMethod("PairwiseComps", "PipelineTemplate", function(obj, value) {
obj@PairwiseComparisons <- value
validObject(obj)
obj
})
#' @export
setGeneric("rmDatasetByIndice", function(obj, ind) standardGeneric("rmDatasetByIndice"))
#' @title Set the rmDatasetByIndice slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param ind xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("rmDatasetByIndice", "PipelineTemplate", function(obj, ind) {
#mae <- callNextMethod()
experiments(obj) <- experiments(obj)[-ind]
validObject(obj)
obj
})
#' @export
setGeneric("rmDatasetByName", function(obj, name) standardGeneric("rmDatasetByName"))
#' @title Set the rmDatasetByName slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param name xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("rmDatasetByName", "PipelineTemplate", function(obj, name) {
#mae <- callNextMethod()
experiments(obj) <- within(experiments(obj), rm(name))
validObject(obj)
obj
})
#' @export
setGeneric("addDataset", function(obj, name, dataset) standardGeneric("addDataset"))
#' @title Set the addDataset slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param name xxx
#' @param dataset xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("addDataset", "PipelineTemplate", function(obj, name, dataset) {
#mae <- callNextMethod()
ds <- list()
ds[[name]]<- dataset
obj <- c(obj, ds)
validObject(obj)
obj
})
#' @export
setGeneric("updateDataset<-", function(obj, name, value) standardGeneric("updateDataset<-"))
#' @title Set the updateDataset slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param name xxx
#' @param value xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setReplaceMethod("updateDataset", "PipelineTemplate", function(obj, name, value) {
#mae <- callNextMethod()
.checkIfAnalysisExists(obj, name)
experiments(obj)[[name]] <- value
validObject(obj)
obj
})
#' @export
setGeneric("dataset", function(obj, name) standardGeneric("dataset"))
#' @title Get a dataset slot value for the object
#' @description sfklsjhf qsjdhsqd.
#' @param obj xxxx
#' @param name xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
setMethod("dataset", "PipelineTemplate", function(obj, name) {
#mae <- callNextMethod()
.checkIfAnalysisExists(obj, name)
out <- experiments(obj)[[name]]
out
})
#' @title Check if xxx
#' @description sfklsjhf qsjdhsqd.
#' @param object xxxx
#' @param name xxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
.checkIfAnalysisExists <- function(object, name)
{
if (!(name %in% names(assays(object)))){
warning("The dataset called name was not found")
return(NULL)
}
if (class(name) != "character"){
warning("The name parameter must be a string.")
return(NULL)
}
}
#' @title Check if xxx
#' @description sfklsjhf qsjdhsqd.
#' @param object xxxx
#' @return xxxx
#' @author Samuel Wieczorek
#' @examples
#' utils::data(Exp1_R25_prot)
#' @export
.validPipelineTemplate <- function(object) {
#if (length(experiments(object)) != 0L) {
# }
}
S4Vectors::setValidity2("PipelineTemplate", .validPipelineTemplate)
install.packages("~/TELETRAVAIL/github_2.0/DAPAR/", repo = NULL, type="source")
library(DAPAR)
source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
library(shiny)
library(DAPAR)
library(Biobase)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
install.packages("~/TELETRAVAIL/github_2.0/DAPAR/", repo = NULL, type="source")
library(shiny)
library(DAPAR)
library(Biobase)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
library(shiny)
library(DAPAR)
library(Biobase)
library(MultiAssayExperiment)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
#source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
library(shiny)
library(DAPAR)
library(Biobase)
library(MultiAssayExperiment)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
#source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
library(shiny)
library(DAPAR)
library(Biobase)
library(MultiAssayExperiment)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
#source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
View(Exp1_R25_prot)
runApp('~/TELETRAVAIL/github_2.0/Prostar2/dev/test_dev/test-mod_open_demo_dataset.R')
runApp('~/TELETRAVAIL/github_2.0/Prostar2/dev/test_dev/test-mod_open_demo_dataset.R')
library(shiny)
library(DAPAR)
library(Biobase)
library(MultiAssayExperiment)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
#source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
library(shiny)
library(DAPAR)
library(Biobase)
library(MultiAssayExperiment)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
#source(file.path('~/TELETRAVAIL/github_2.0/DAPAR/R/pipeline-template-class.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
library(shiny)
library(DAPAR)
library(MultiAssayExperiment)
source(file.path('../../R', 'mod_open_demo_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_choose_pipeline.R'), local=TRUE)$value
source(file.path('../../R', 'mod_infos_dataset.R'), local=TRUE)$value
source(file.path('../../R', 'mod_format_DT.R'), local=TRUE)$value
source(file.path('../../R', 'commonFunc.R'), local=TRUE)$value
source(file.path('../../R', 'global.R'), local=TRUE)$value
actionBtnClass <- "btn-primary"
ui <- fluidPage(
tagList(
mod_open_demo_dataset_ui('rl')
)
)
# Define server logic to summarize and view selected dataset ----
server <- function(input, output, session) {
rv <- reactiveValues(
demoData = NULL
)
defs <- ReadPipelineConfig('../../R/pipeline.conf')
rv$demoData <- callModule(mod_open_demo_dataset_server, "rl", pipeline.def=reactive({defs}))
}
shinyApp(ui, server)
